'''
Events class definining all of the possible State transformations
which define the Edges in the Tree/Graph structure generated by step/time-evolving
the system.


name:       name/id of the transformation to be performed.
is_viable:  "SAT" problem (Is the input for the given Action/Transform "Satisfied"/viable

actions to be taken from the given

is_viable:  Checks whether the given state would permit such an action:
            ex: if required resources are met, action is viable
            If required resources are not met, action is not viable

apply:      "Pure" function taking in a given World State, and applies
            the underlying "Action" resulting in a new World State.

'''

from abc import ABC, abstractmethod
from world import WorldState
from country import Country
from resource import Resource

# Uses abstract methods as a means to express some static polymorphism/Inheritence


class Action(ABC):

    name: str

    @abstractmethod
    def is_viable(self, state: WorldState, **kwargs) -> bool:
        return False

    @abstractmethod
    def apply(self, state: WorldState, **kwargs) -> int:
        return 0


class Transform(Action):

    def is_viable(self, state: WorldState, **kwargs) -> bool:
        return False

    # "Flux" like pattern, taking in a current state
    def apply(self, state: WorldState, **kwargs) -> int:
        return 0


class Transfer(Action):
    pass


'''
Alloys Template:
((TRANSFORM ?C (INPUTS (R1 1) (R2, 2)) (OUTPUTS (R1 1) (R21, 1) (R21’ 1)),
preconditions are of the form ?ARj <= ?C(?Rj)
'''


class AlloyTemplate(Transform):

    def is_viable(self, world: WorldState, **kwargs):
        c: Country = world.countries[0]
        return c.resources['R1'].quantity >= 1 \
            and c.resources['R2'].quantity >= 2

    # returns the 'factor' applied for the given base operation/inputs
    def apply(self, world: WorldState, **kwargs) -> int:
        c: Country = world.countries[0]

        # use up to half of resources on given transform
        factor: int = max([1, int(c.resources['R2'].quantity / 4)])

        r2_consumed: int = factor * 2
        r21_gained: int = factor
        r21_waist_gained: int = factor

        c.resources['R2'].quantity -= r2_consumed
        c.resources['R21'].quantity += r21_gained
        c.resources["R21'"].quantity += r21_waist_gained

        return factor


'''
Electronics Template:
(TRANSFORM ?C (INPUTS (R1 3) (R2 2) (R21 2)) (OUTPUTS (R22 2) (R22’ 2) (R1 3)),
preconditions are of the form ?ARj <= ?C(?Rj)
'''


class ElectronicsTemplate(Transform):

    def is_viable(self, world: WorldState, **kwargs):
        c: Country = world.countries[0]
        return c.resources['R1'].quantity >= 3 \
            and c.resources['R2'].quantity >= 2 \
            and c.resources['R21'].quantity >= 2

    # returns the 'factor' applied for the given base operation/inputs
    def apply(self, world: WorldState, **kwargs) -> int:
        c: Country = world.countries[0]

        # use up to half of resources on given transform
        r2_max_factor: int = max([1, int(c.resources['R2'].quantity / 4)])
        r21_max_factor: int = max([1, int(c.resources['R21'].quantity / 4)])

        factor: int = min([r2_max_factor, r21_max_factor])

        r2_consumed: int = factor * 2
        r21_consumed: int = factor * 2

        r22_gained: int = factor * 2
        r22_waist_gained: int = factor * 2

        c.resources['R2'].quantity -= r2_consumed
        c.resources['R21'].quantity -= r21_consumed
        c.resources['R22'].quantity += r22_gained
        c.resources["R22'"].quantity += r22_waist_gained

        return factor


'''
Housing Template:
(TRANSFORM ?C (INPUTS (R1 5) (R2, 1) (R3 5) (R21 3) (OUTPUTS (R1 5) (R23, 1) (R23’ 1)),
preconditions are of the form ?AIk <= ?C(?Rk)
'''


class HousingTemplate(Transform):

    def is_viable(self, world: WorldState, **kwargs):
        c: Country = world.countries[0]
        return c.resources['R1'].quantity >= 5 \
            and c.resources['R2'].quantity >= 1 \
            and c.resources['R3'].quantity >= 5 \
            and c.resources['R21'].quantity >= 3

    # returns the 'factor' applied for the given base operation/inputs
    def apply(self, world: WorldState, **kwargs) -> int:
        c: Country = world.countries[0]

        # use up to half of resources on given transform
        r2_max_factor: int = max([1, int(c.resources['R2'].quantity / 2)])
        r3_max_factor: int = max([1, int(c.resources['R3'].quantity / 10)])
        r21_max_factor: int = max([1, int(c.resources['R21'].quantity / 6)])

        factor: int = min([r2_max_factor, r3_max_factor, r21_max_factor])

        r2_consumed: int = factor
        r3_consumed: int = factor * 5
        r21_consumed: int = factor * 3

        r23_gained: int = factor
        r23_waist_gained: int = factor

        c.resources['R2'].quantity -= r2_consumed
        c.resources['R3'].quantity -= r3_consumed
        c.resources['R21'].quantity -= r21_consumed

        c.resources['R23'].quantity += r23_gained
        c.resources["R23'"].quantity += r23_waist_gained

        return factor


action_map: dict = {
    'Alloy Template': AlloyTemplate(),
    'Electronics Template': ElectronicsTemplate(),
    'Housing Template': HousingTemplate(),
}
